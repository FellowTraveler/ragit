use crate::INDEX_DIR_NAME;
use crate::chunk::CHUNK_DIR_NAME;
use crate::error::Error;
use crate::index::{FILE_INDEX_DIR_NAME, IMAGE_DIR_NAME, Index};
use lazy_static::lazy_static;
use ragit_fs::{
    WriteMode,
    extension,
    file_name,
    is_dir,
    join3,
    join4,
    read_bytes,
    read_dir,
    write_string,
};
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::str::FromStr;

/// Each chunk, image and file has uid.
///
/// Uid is a 256 bit hash value, generated by sha3-256 hash function and some postprocessing.
/// The most convenient way for users to deal with uid is using `uid_query` function. The user
/// inputs a hex representation of a uid, or a prefix of it, and the function returns
/// matched uids.
///
/// File uid and chunk uid has a small difference and ragit uses the difference to distinguish
/// chunks and files. When a file uid is represented in hexadecimal, the last 12 characters of the hex
/// are always numbers (no alphabets). And the numbers represents the length of the file, in bytes.
/// For a chunk uid, it's guaranteed that at least one character of the last 12 characters is an
/// alphabet. There must also be a marker for image uids, but I haven't implemented one yet.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct Uid {
    high: u128,
    low: u128,
}

lazy_static! {
    // full or prefix
    static ref UID_RE: Regex = Regex::new(r"^([0-9a-z]{1,64})$").unwrap();
}

// `Vec<Uid>` has multiple serialization formats, though only 1 is implemented now.
// Format 1, naive format: store hex representations of uids, using newline character as a delimiter.
// Format 2, compact format: TODO
pub fn load_from_file(path: &str) -> Result<Vec<Uid>, Error> {
    let bytes = read_bytes(path)?;

    match bytes.get(0) {
        Some((b'a'..=b'f') | (b'0'..=b'9')) => match String::from_utf8(bytes) {
            Ok(s) => {
                let mut result = vec![];

                for line in s.lines() {
                    result.push(line.parse::<Uid>()?);
                }

                Ok(result)
            },
            Err(_) => Err(Error::CorruptedFile(path.to_string())),
        },
        Some(b) => Err(Error::CorruptedFile(path.to_string())),
        None => Ok(vec![]),
    }
}

// For now, it only supports naive format.
pub fn save_to_file(
    path: &str,
    uids: &[Uid],
) -> Result<(), Error> {
    Ok(write_string(
        path,
        &uids.iter().map(|uid| uid.to_string()).collect::<Vec<_>>().join("\n"),
        WriteMode::CreateOrTruncate,
    )?)
}

impl Uid {
    pub(crate) fn dummy() -> Self {
        Uid {
            high: 0,
            low: 0,
        }
    }

    pub(crate) fn from_prefix_and_suffix(prefix: &str, suffix: &str) -> Result<Self, Error> {
        if prefix.len() != 2 || suffix.len() != 62 {
            Err(Error::InvalidUid(format!("{prefix}{suffix}")))
        }

        else {
            match (suffix.get(0..30), suffix.get(30..)) {
                (Some(high_suff), Some(low)) => match (
                    u128::from_str_radix(&format!("{prefix}{high_suff}"), 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(Error::InvalidUid(format!("{prefix}{suffix}"))),
                },
                _ => Err(Error::InvalidUid(format!("{prefix}{suffix}"))),
            }
        }
    }

    pub(crate) fn get_prefix(&self) -> String {
        format!("{:02x}", self.high >> 120)
    }

    pub(crate) fn get_suffix(&self) -> String {
        format!("{:030x}{:032x}", self.high & 0xff_ffff_ffff_ffff_ffff_ffff_ffff_ffff, self.low)
    }

    pub(crate) fn get_file_size(&self) -> Result<usize, Error> {
        let low = format!("{:x}", self.low & 0xffff_ffff_ffff);
        low.parse::<usize>().map_err(|e| Error::InvalidUid(self.to_string()))
    }
}

impl fmt::Display for Uid {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(fmt, "{:032x}{:032x}", self.high, self.low)
    }
}

impl FromStr for Uid {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Error> {
        if s.len() != 64 {
            Err(Error::InvalidUid(s.to_string()))
        }

        else {
            match (s.get(0..32), s.get(32..)) {
                (Some(high), Some(low)) => match (
                    u128::from_str_radix(high, 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(Error::InvalidUid(s.to_string())),
                },
                _ => Err(Error::InvalidUid(s.to_string())),
            }
        }
    }
}

impl Index {
    pub fn get_all_chunk_uids(&self) -> Result<Vec<Uid>, Error> {
        let mut result = vec![];

        // TODO: search external bases
        for internal in read_dir(&join3(&self.root_dir, &INDEX_DIR_NAME, &CHUNK_DIR_NAME)?)? {
            let prefix = file_name(&internal)?;

            if !is_dir(&internal) {
                continue;
            }

            for chunk_file in read_dir(&internal)? {
                if extension(&chunk_file).unwrap_or(None).unwrap_or(String::new()) == "chunk" {
                    result.push(Uid::from_prefix_and_suffix(&prefix, &file_name(&chunk_file)?)?);
                }
            }
        }

        Ok(result)
    }

    // TODO: use 2-level structure, like others
    pub fn get_all_image_uids(&self) -> Result<Vec<Uid>, Error> {
        let mut result = vec![];

        for image in read_dir(&join3(&self.root_dir, &INDEX_DIR_NAME, &IMAGE_DIR_NAME)?)? {
            if extension(&image).unwrap_or(None).unwrap_or(String::new()) == "png" {
                result.push(file_name(&image)?.parse::<Uid>()?);
            }
        }

        Ok(result)
    }

    pub fn get_all_file_uids(&self) -> Vec<Uid> {
        self.processed_files.values().map(|uid| *uid).collect()
    }

    /// General purpose uid query for many commands: `ls-chunks`, `ls-files`, `tfidf --show` ...
    ///
    /// It first queries chunk uids and file uids that starts with `q`.
    /// If no uid's found, it treats `q` like a file path and tries to
    /// find a file uid of a file who has the uid. It doesn't do a
    /// prefix-matching when querying file paths.
    pub fn uid_query(&self, q: UidQuery) -> Result<UidQueryResult, Error> {
        if q.query.is_empty() {
            return Ok(UidQueryResult::empty());
        }

        let mut chunks = vec![];
        let mut images = vec![];
        let mut staged_files = vec![];

        // below 2 are for processed files
        let mut file_uids = vec![];
        let mut file_paths = vec![];

        // TODO: search external bases
        if UID_RE.is_match(&q.query) {
            if q.query.len() == 1 {
                if q.search_chunk {
                    for chunk_dir in read_dir(&join3(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        CHUNK_DIR_NAME,
                    )?).unwrap_or(vec![]) {
                        let chunk_prefix = file_name(&chunk_dir)?;

                        if chunk_prefix.starts_with(&q.query) {
                            for chunk_file in read_dir(&chunk_dir)? {
                                if extension(&chunk_file)?.unwrap_or(String::new()) != "chunk" {
                                    continue;
                                }

                                chunks.push(Uid::from_prefix_and_suffix(&chunk_prefix, &file_name(&chunk_file)?)?);
                            }
                        }
                    }
                }

                if q.search_file_uid {
                    for file_index_dir in read_dir(&join3(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        FILE_INDEX_DIR_NAME,
                    )?).unwrap_or(vec![]) {
                        let file_index_prefix = file_name(&file_index_dir)?;

                        if file_index_prefix.starts_with(&q.query) {
                            for file_index in read_dir(&file_index_dir)? {
                                file_uids.push(Uid::from_prefix_and_suffix(&file_index_prefix, &file_name(&file_index)?)?);
                            }
                        }
                    }
                }
            }

            else if q.query.len() == 2 {
                if q.search_chunk {
                    for chunk_file in read_dir(&join4(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        CHUNK_DIR_NAME,
                        &q.query,
                    )?).unwrap_or(vec![]) {
                        if extension(&chunk_file)?.unwrap_or(String::new()) != "chunk" {
                            continue;
                        }

                        chunks.push(Uid::from_prefix_and_suffix(&q.query, &file_name(&chunk_file)?)?);
                    }
                }

                if q.search_file_uid {
                    for file_index in read_dir(&join4(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        FILE_INDEX_DIR_NAME,
                        &q.query,
                    )?).unwrap_or(vec![]) {
                        file_uids.push(Uid::from_prefix_and_suffix(&q.query, &file_name(&file_index)?)?);
                    }
                }
            }

            // TODO: a small optimization: if q is 64 characters long, don't iterate
            else {
                let prefix = q.query.get(0..2).unwrap().to_string();
                let suffix = q.query.get(2..).unwrap().to_string();

                if q.search_chunk {
                    for chunk_file in read_dir(&join4(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        CHUNK_DIR_NAME,
                        &prefix,
                    )?).unwrap_or(vec![]) {
                        if extension(&chunk_file)?.unwrap_or(String::new()) != "chunk" {
                            continue;
                        }

                        let chunk_file = file_name(&chunk_file)?;

                        if chunk_file.starts_with(&suffix) {
                            chunks.push(Uid::from_prefix_and_suffix(&prefix, &chunk_file)?);
                        }
                    }
                }

                if q.search_file_uid {
                    for file_index in read_dir(&join4(
                        &self.root_dir,
                        INDEX_DIR_NAME,
                        FILE_INDEX_DIR_NAME,
                        &prefix,
                    )?).unwrap_or(vec![]) {
                        let file_index = file_name(&file_index)?;

                        if file_index.starts_with(&suffix) {
                            file_uids.push(Uid::from_prefix_and_suffix(&prefix, &file_index)?);
                        }
                    }
                }
            }
        }

        // TODO: impl 2-level structure for images, then put this in the loop above
        if q.search_image {
            for image_file in read_dir(&join3(&self.root_dir, &INDEX_DIR_NAME, &IMAGE_DIR_NAME)?)? {
                if extension(&image_file).unwrap_or(None).unwrap_or(String::new()) == "png" && file_name(&image_file)?.starts_with(&q.query) {
                    images.push(file_name(&image_file)?.parse::<Uid>()?);
                }
            }
        }

        if q.search_file_path {
            // TODO: enable file prefix-matching
            //       there's an issue with file prefix-matching. if a file path is a prefix
            //       of another file, there's no way to exact-match the file
            if let Ok(rel_path) = Index::get_rel_path(&self.root_dir, &q.query.to_string()) {
                if self.processed_files.contains_key(&rel_path) {
                    file_paths.push(rel_path.to_string());
                }

                if q.search_staged_file && self.staged_files.contains(&rel_path) {
                    staged_files.push(rel_path);
                }
            }
        }

        let mut processed_files = HashSet::with_capacity(file_paths.len() + file_uids.len());
        let processed_files_rev: HashMap<_, _> = self.processed_files.iter().map(
            |(file, uid)| (*uid, file.to_string())
        ).collect();

        for path in file_paths.iter() {
            processed_files.insert((path.to_string(), *self.processed_files.get(path).unwrap()));
        }

        for uid in file_uids.iter() {
            processed_files.insert((processed_files_rev.get(uid).unwrap().to_string(), *uid));
        }

        Ok(UidQueryResult {
            chunks,
            images,
            processed_files: processed_files.into_iter().collect(),
            staged_files,
        })
    }
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UidQuery {
    /// It can be a prefix of uid, full uid, or a file path
    pub query: String,
    pub search_chunk: bool,
    pub search_image: bool,
    pub search_file_path: bool,
    pub search_file_uid: bool,

    /// It searches staged files when both `search_file_path` and `search_staged_file` are set.
    pub search_staged_file: bool,
}

impl UidQuery {
    pub fn with_query(query: String) -> Self {
        UidQuery {
            query,
            search_chunk: true,
            search_image: true,
            search_file_path: true,
            search_file_uid: true,
            search_staged_file: true,
        }
    }

    pub fn file_or_chunk(mut self) -> Self {
        self.search_chunk = true;
        self.search_file_path = true;
        self.search_file_uid = true;
        self
    }

    pub fn file_only(mut self) -> Self {
        self.search_chunk = false;
        self.search_image = false;
        self.search_file_path = true;
        self.search_file_uid = true;
        self
    }

    pub fn no_staged_file(mut self) -> Self {
        self.search_staged_file = false;
        self
    }
}

#[derive(Clone, Debug)]
pub struct UidQueryResult {
    pub chunks: Vec<Uid>,
    pub images: Vec<Uid>,
    pub processed_files: Vec<(String, Uid)>,
    pub staged_files: Vec<String>,
}

impl UidQueryResult {
    fn empty() -> Self {
        UidQueryResult {
            chunks: vec![],
            images: vec![],
            processed_files: vec![],
            staged_files: vec![],
        }
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn has_multiple_matches(&self) -> bool {
        self.len() > 1
    }

    pub fn len(&self) -> usize {
        self.chunks.len() + self.images.len() + self.processed_files.len() + self.staged_files.len()
    }

    pub fn get_chunk_uids(&self) -> Vec<Uid> {
        self.chunks.clone()
    }

    pub fn get_image_uids(&self) -> Vec<Uid> {
        self.images.clone()
    }

    pub fn get_file_uids(&self) -> Vec<Uid> {
        self.processed_files.iter().map(|(_, uid)| *uid).collect()
    }

    pub fn get_processed_files(&self) -> Vec<(String, Uid)> {
        self.processed_files.clone()
    }

    pub fn get_staged_files(&self) -> Vec<String> {
        self.staged_files.clone()
    }

    /// It returns `Some` iff there's only 1 match.
    pub fn get_processed_file(&self) -> Option<(String, Uid)> {
        if self.processed_files.len() == 1 {
            Some(self.processed_files[0].clone())
        }

        else {
            None
        }
    }

    /// It returns `Some` iff there's only 1 match.
    pub fn get_chunk_uid(&self) -> Option<Uid> {
        if self.chunks.len() == 1 {
            Some(self.chunks[0])
        }

        else {
            None
        }
    }

    /// It returns `Some` iff there's only 1 match.
    pub fn get_image_uid(&self) -> Option<Uid> {
        if self.images.len() == 1 {
            Some(self.images[0])
        }

        else {
            None
        }
    }
}
